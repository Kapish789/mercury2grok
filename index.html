<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Futuristic Liquid Metal Effect</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: 'Orbitron', sans-serif;
      background: linear-gradient(135deg, #0d1b2a, #1b263b);
      color: #e0e7ff;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
    }
    .container {
      display: flex;
      align-items: center;
      gap: 30px;
      padding: 30px;
      backdrop-filter: blur(10px);
    }
    #canvas-container {
      width: 450px;
      height: 450px;
      background: #1a1a1a;
      border-radius: 15px;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
      display: flex;
      justify-content: center;
      align-items: center;
      transition: transform 0.3s ease;
    }
    #canvas-container:hover {
      transform: scale(1.02);
    }
    .controls {
      background: rgba(26, 34, 54, 0.8);
      padding: 25px;
      border-radius: 15px;
      width: 320px;
      border: 1px solid rgba(0, 255, 255, 0.2);
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
      backdrop-filter: blur(5px);
    }
    .control-group {
      margin-bottom: 20px;
    }
    .control-group label {
      display: block;
      font-size: 14px;
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: #00f7ff;
    }
    .control-group input[type="range"] {
      width: 100%;
      accent-color: #00f7ff;
      background: linear-gradient(to right, #00f7ff 0%, #1b263b 100%);
      border-radius: 5px;
      cursor: pointer;
    }
    .control-group input[type="range"]::-webkit-slider-thumb {
      box-shadow: 0 0 10px #00f7ff;
    }
    .control-group span {
      display: inline-block;
      width: 60px;
      text-align: right;
      font-size: 14px;
      color: #e0e7ff;
    }
    .upload-btn {
      background: linear-gradient(90deg, #00f7ff, #007bff);
      color: #fff;
      padding: 12px;
      border: none;
      border-radius: 8px;
      width: 100%;
      cursor: pointer;
      text-transform: uppercase;
      font-size: 14px;
      letter-spacing: 1px;
      transition: transform 0.2s ease, box-shadow 0.3s ease;
    }
    .upload-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 0 20px rgba(0, 247, 255, 0.5);
    }
    .tips {
      font-size: 12px;
      color: #a3bffa;
      margin-top: 15px;
      line-height: 1.5;
    }
    .background-picker {
      display: flex;
      gap: 15px;
      margin-bottom: 20px;
    }
    .background-picker div {
      width: 35px;
      height: 35px;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid transparent;
      transition: border 0.3s ease, transform 0.3s ease;
    }
    .background-picker div:hover {
      transform: scale(1.1);
    }
    .background-picker div.selected {
      border-color: #00f7ff;
      box-shadow: 0 0 10px #00f7ff;
    }
    .bg-metal { background: linear-gradient(45deg, #666, #999); }
    .bg-black { background: #000; }
    .bg-colorful { background: linear-gradient(45deg, #f00, #0f0, #00f); }
    input[type="file"] {
      display: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <div id="canvas-container"></div>
    <div class="controls">
      <div class="background-picker">
        <div class="bg-metal selected" data-bg="metal"></div>
        <div class="bg-black" data-bg="black"></div>
        <div class="bg-colorful" data-bg="colorful"></div>
      </div>
      <div class="control-group">
        <label>Refraction</label>
        <input type="range" id="refraction" min="0" max="1" step="0.01" value="0.04">
        <span>0.040</span>
      </div>
      <div class="control-group">
        <label>Edge</label>
        <input type="range" id="edge" min="0" max="1" step="0.01" value="1">
        <span>1.000</span>
      </div>
      <div class="control-group">
        <label>Pattern Blur</label>
        <input type="range" id="patternBlur" min="0" max="1" step="0.01" value="0">
        <span>0.000</span>
      </div>
      <div class="control-group">
        <label>Liquid</label>
        <input type="range" id="liquid" min="0" max="1" step="0.01" value="0.61">
        <span>0.610</span>
      </div>
      <div class="control-group">
        <label>Speed</label>
        <input type="range" id="speed" min="0" max="2" step="0.01" value="1">
        <span>1.000</span>
      </div>
      <div class="control-group">
        <label>Pattern Scale</label>
        <input type="range" id="patternScale" min="1" max="20" step="1" value="10">
        <span>10</span>
      </div>
      <input type="file" id="imageUpload" accept="image/svg+xml,image/png,image/jpeg">
      <button class="upload-btn" onclick="document.getElementById('imageUpload').click()">Upload Image</button>
      <div class="tips">
        Tips: Transparent or white background works best. Shapes are better than text. Use SVG or high-res images (500px-1000px recommended). Max 4.5MB.
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.min.js"></script>
  <script>
    // Scene setup
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(450, 450);
    renderer.setClearColor(0x1a1a1a, 1);
    container.appendChild(renderer.domElement);

    // Default Apple logo SVG as a mask
    let defaultSvg = `
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" width="100" height="100">
        <path fill="white" d="M64.4 17.5c-2.8 3.6-7.2 6.5-12.5 6.5-1.5 0-3.8-.5-5.7-1.8-1.8-1.2-3.6-3-5.3-5.3-3.5-5-5.7-11.2-5.7-17.5 0-1.5.2-3 .7-4.5 2.8-8.2 10.5-13.8 19.2-13.8 6.8 0 12.8 3.2 16.5 8.2 1.5 2 2.5 4.5 2.5 7.2 0 4.5-2.5 8.8-6.7 12.5zM49.5 99.5c-10.5 0-18.5-5.2-23.5-14.5-5-9.2-6.5-21.5-4.5-34.5 1-6.5 3.2-12.5 6.5-18 3.2-5.5 7.2-9.8 12-12.8 1.5-1 3.2-1.5 5-1.5 3.5 0 6.8 1.5 9.5 4 2.8 2.5 4.5 6 5.5 9.8 1 3.8 1.5 8 1.5 12.2 0 10.5-3.2 20.5-9 28.5-3.8 5.2-8.5 9-14 11.5z"/>
      </svg>
    `;
    let svgTexture = new THREE.TextureLoader().load('data:image/svg+xml,' + encodeURIComponent(defaultSvg));
    svgTexture.minFilter = THREE.LinearFilter;
    svgTexture.magFilter = THREE.LinearFilter;

    // Shader uniforms
    const uniforms = {
      uTime: { value: 0 },
      uRefraction: { value: 0.04 },
      uEdge: { value: 1.0 },
      uPatternBlur: { value: 0.0 },
      uLiquid: { value: 0.61 },
      uSpeed: { value: 1.0 },
      uPatternScale: { value: 10.0 },
      uMask: { value: svgTexture },
      uBackground: { value: new THREE.Vector3(0.4, 0.4, 0.4) }
    };

    // Shader material
    const material = new THREE.ShaderMaterial({
      uniforms,
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        varying vec2 vUv;
        uniform float uTime;
        uniform float uRefraction;
        uniform float uEdge;
        uniform float uPatternBlur;
        uniform float uLiquid;
        uniform float uSpeed;
        uniform float uPatternScale;
        uniform sampler2D uMask;
        uniform vec3 uBackground;

        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }
        float snoise(vec2 v) {
          const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
          vec2 i  = floor(v + dot(v, C.yy));
          vec2 x0 = v - i + dot(i, C.xx);
          vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
          vec4 x12 = x0.xyxy + C.xxzz;
          x12.xy -= i1;
          i = mod289(i);
          vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
          vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
          m = m*m;
          m = m*m;
          vec3 x = 2.0 * fract(p * C.www) - 1.0;
          vec3 h = abs(x) - 0.5;
          vec3 ox = floor(x + 0.5);
          vec3 a0 = x - ox;
          m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);
          vec3 g;
          g.x  = a0.x  * x0.x  + h.x  * x0.y;
          g.yz = a0.yz * x12.xz + h.yz * x12.yw;
          return 130.0 * dot(m, g);
        }

        void main() {
          vec2 uv = vUv * uPatternScale;
          float time = uTime * uSpeed;

          float n1 = snoise(uv + time * 0.1);
          float n2 = snoise(uv * 0.5 + time * 0.05);
          vec2 offset = vec2(n1, n2) * uLiquid * 0.1;

          vec2 refractedUV = uv + offset * uRefraction;
          float noise = snoise(refractedUV);

          vec3 color = uBackground + noise * 0.3;
          color += vec3(1.0) * pow(max(0.0, dot(normalize(vec3(offset, 1.0)), vec3(0.0, 0.0, 1.0))), uEdge);

          float mask = texture2D(uMask, vUv).r;
          if (mask < 0.1) {
            color = vec3(0.0);
          }

          if (uPatternBlur > 0.0) {
            vec2 blurOffset = vec2(uPatternBlur * 0.01);
            float blurSample = snoise(refractedUV + blurOffset);
            color += vec3(blurSample) * uPatternBlur * 0.1;
          }

          gl_FragColor = vec4(color, mask);
        }
      `
    });

    // Geometry and mesh
    const geometry = new THREE.PlaneGeometry(2, 2);
    const mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      uniforms.uTime.value += 0.016;
      renderer.render(scene, camera);
    }
    animate();

    // Handle image upload
    const imageUpload = document.getElementById('imageUpload');
    imageUpload.addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (!file) return;

      // Validate file size (max 4.5MB)
      const maxSize = 4.5 * 1024 * 1024; // 4.5MB in bytes
      if (file.size > maxSize) {
        alert('File size exceeds 4.5MB. Please upload a smaller image.');
        return;
      }

      // Validate file type
      const validTypes = ['image/svg+xml', 'image/png', 'image/jpeg'];
      if (!validTypes.includes(file.type)) {
        alert('Please upload an SVG, PNG, or JPEG image.');
        return;
      }

      const reader = new FileReader();
      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
          const texture = new THREE.Texture(img);
          texture.needsUpdate = true;
          texture.minFilter = THREE.LinearFilter;
          texture.magFilter = THREE.LinearFilter;
          uniforms.uMask.value = texture;
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    });

    // Handle slider inputs
    const sliders = {
      refraction: document.getElementById('refraction'),
      edge: document.getElementById('edge'),
      patternBlur: document.getElementById('patternBlur'),
      liquid: document.getElementById('liquid'),
      speed: document.getElementById('speed'),
      patternScale: document.getElementById('patternScale')
    };

    Object.keys(sliders).forEach(key => {
      const slider = sliders[key];
      slider.addEventListener('input', () => {
        uniforms[`u${key.charAt(0).toUpperCase() + key.slice(1)}`].value = parseFloat(slider.value);
        slider.nextElementSibling.textContent = parseFloat(slider.value).toFixed(3);
      });
    });

    // Handle background picker
    const backgroundPicker = document.querySelectorAll('.background-picker div');
    backgroundPicker.forEach(div => {
      div.addEventListener('click', () => {
        backgroundPicker.forEach(d => d.classList.remove('selected'));
        div.classList.add('selected');
        const bg = div.dataset.bg;
        if (bg === 'metal') uniforms.uBackground.value.set(0.4, 0.4, 0.4);
        else if (bg === 'black') uniforms.uBackground.value.set(0.0, 0.0, 0.0);
        else uniforms.uBackground.value.set(0.5, 0.5, 0.5);
      });
    });

    // Handle window resize
    window.addEventListener('resize', () => {
      const size = Math.min(container.clientWidth, container.clientHeight);
      renderer.setSize(size, size);
    });
  </script>
</body>
</html>