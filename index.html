<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Liquid Metal Effect</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      background: #000;
      color: #fff;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
    }
    .container {
      display: flex;
      align-items: center;
      gap: 20px;
      padding: 20px;
    }
    #canvas-container {
      width: 400px;
      height: 400px;
      background: #1a1a1a;
      border-radius: 10px;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .controls {
      background: #2a2a2a;
      padding: 20px;
      border-radius: 10px;
      width: 300px;
    }
    .control-group {
      margin-bottom: 15px;
    }
    .control-group label {
      display: block;
      font-size: 14px;
      margin-bottom: 5px;
      text-transform: uppercase;
    }
    .control-group input[type="range"] {
      width: 100%;
      accent-color: #1e90ff;
    }
    .control-group span {
      display: inline-block;
      width: 50px;
      text-align: right;
      font-size: 14px;
    }
    .upload-btn {
      background: #1e90ff;
      color: #fff;
      padding: 10px;
      border: none;
      border-radius: 5px;
      width: 100%;
      cursor: pointer;
      text-transform: uppercase;
      font-size: 14px;
    }
    .tips {
      font-size: 12px;
      color: #aaa;
      margin-top: 10px;
    }
    .background-picker {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
    }
    .background-picker div {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid transparent;
    }
    .background-picker div.selected {
      border-color: #fff;
    }
    .bg-metal { background: linear-gradient(45deg, #666, #999); }
    .bg-black { background: #000; }
    .bg-colorful { background: linear-gradient(45deg, #f00, #0f0, #00f); }
  </style>
</head>
<body>
  <div class="container">
    <div id="canvas-container"></div>
    <div class="controls">
      <div class="background-picker">
        <div class="bg-metal selected" data-bg="metal"></div>
        <div class="bg-black" data-bg="black"></div>
        <div class="bg-colorful" data-bg="colorful"></div>
      </div>
      <div class="control-group">
        <label>Refraction</label>
        <input type="range" id="refraction" min="0" max="1" step="0.01" value="0.04">
        <span>0.040</span>
      </div>
      <div class="control-group">
        <label>Edge</label>
        <input type="range" id="edge" min="0" max="1" step="0.01" value="1">
        <span>1.000</span>
      </div>
      <div class="control-group">
        <label>Pattern Blur</label>
        <input type="range" id="patternBlur" min="0" max="1" step="0.01" value="0">
        <span>0.000</span>
      </div>
      <div class="control-group">
        <label>Liquid</label>
        <input type="range" id="liquid" min="0" max="1" step="0.01" value="0.61">
        <span>0.610</span>
      </div>
      <div class="control-group">
        <label>Speed</label>
        <input type="range" id="speed" min="0" max="2" step="0.01" value="1">
        <span>1.000</span>
      </div>
      <div class="control-group">
        <label>Pattern Scale</label>
        <input type="range" id="patternScale" min="1" max="20" step="1" value="10">
        <span>10</span>
      </div>
      <button class="upload-btn">Upload Image</button>
      <div class="tips">
        Tips: Transparent or white background works best. Shapes are better than text. Use SVG or high-res images (500px-1000px recommended). Max 4.5MB.
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.min.js"></script>
  <script>
    // Scene setup
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(400, 400);
    renderer.setClearColor(0x1a1a1a, 1); // Set a visible background color for debugging
    container.appendChild(renderer.domElement);

    // Check WebGL support
    if (!renderer.getContext()) {
      console.error("WebGL is not supported in this browser.");
    }

    // Apple logo SVG as a mask (simplified path)
    const svgData = `
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" width="100" height="100">
        <path fill="white" d="M64.4 17.5c-2.8 3.6-7.2 6.5-12.5 6.5-1.5 0-3.8-.5-5.7-1.8-1.8-1.2-3.6-3-5.3-5.3-3.5-5-5.7-11.2-5.7-17.5 0-1.5.2-3 .7-4.5 2.8-8.2 10.5-13.8 19.2-13.8 6.8 0 12.8 3.2 16.5 8.2 1.5 2 2.5 4.5 2.5 7.2 0 4.5-2.5 8.8-6.7 12.5zM49.5 99.5c-10.5 0-18.5-5.2-23.5-14.5-5-9.2-6.5-21.5-4.5-34.5 1-6.5 3.2-12.5 6.5-18 3.2-5.5 7.2-9.8 12-12.8 1.5-1 3.2-1.5 5-1.5 3.5 0 6.8 1.5 9.5 4 2.8 2.5 4.5 6 5.5 9.8 1 3.8 1.5 8 1.5 12.2 0 10.5-3.2 20.5-9 28.5-3.8 5.2-8.5 9-14 11.5z"/>
      </svg>
    `;
    const svgTexture = new THREE.TextureLoader().load('data:image/svg+xml,' + encodeURIComponent(svgData), 
      () => console.log("SVG texture loaded successfully"),
      undefined,
      (err) => console.error("Error loading SVG texture:", err)
    );
    svgTexture.minFilter = THREE.LinearFilter;
    svgTexture.magFilter = THREE.LinearFilter;

    // Shader uniforms
    const uniforms = {
      uTime: { value: 0 },
      uRefraction: { value: 0.04 },
      uEdge: { value: 1.0 },
      uPatternBlur: { value: 0.0 },
      uLiquid: { value: 0.61 },
      uSpeed: { value: 1.0 },
      uPatternScale: { value: 10.0 },
      uMask: { value: svgTexture },
      uBackground: { value: new THREE.Vector3(0.4, 0.4, 0.4) } // Metal color
    };

    // Shader material
    const material = new THREE.ShaderMaterial({
      uniforms,
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        varying vec2 vUv;
        uniform float uTime;
        uniform float uRefraction;
        uniform float uEdge;
        uniform float uPatternBlur;
        uniform float uLiquid;
        uniform float uSpeed;
        uniform float uPatternScale;
        uniform sampler2D uMask;
        uniform vec3 uBackground;

        // Simplex noise (simplified for demo)
        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }
        float snoise(vec2 v) {
          const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
          vec2 i  = floor(v + dot(v, C.yy));
          vec2 x0 = v - i + dot(i, C.xx);
          vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
          vec4 x12 = x0.xyxy + C.xxzz;
          x12.xy -= i1;
          i = mod289(i);
          vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
          vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
          m = m*m;
          m = m*m;
          vec3 x = 2.0 * fract(p * C.www) - 1.0;
          vec3 h = abs(x) - 0.5;
          vec3 ox = floor(x + 0.5);
          vec3 a0 = x - ox;
          m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);
          vec3 g;
          g.x  = a0.x  * x0.x  + h.x  * x0.y;
          g.yz = a0.yz * x12.xz + h.yz * x12.yw;
          return 130.0 * dot(m, g);
        }

        void main() {
          vec2 uv = vUv * uPatternScale;
          float time = uTime * uSpeed;

          // Liquid motion using noise
          float n1 = snoise(uv + time * 0.1);
          float n2 = snoise(uv * 0.5 + time * 0.05);
          vec2 offset = vec2(n1, n2) * uLiquid * 0.1;

          // Apply refraction
          vec2 refractedUV = uv + offset * uRefraction;
          float noise = snoise(refractedUV);

          // Metallic shading
          vec3 color = uBackground + noise * 0.3;
          color += vec3(1.0) * pow(max(0.0, dot(normalize(vec3(offset, 1.0)), vec3(0.0, 0.0, 1.0))), uEdge);

          // Apply mask
          float mask = texture2D(uMask, vUv).r;
          if (mask < 0.1) {
            color = vec3(0.0); // Ensure areas outside the mask are transparent
          }

          // Apply pattern blur (simulated)
          if (uPatternBlur > 0.0) {
            vec2 blurOffset = vec2(uPatternBlur * 0.01);
            float blurSample = snoise(refractedUV + blurOffset);
            color += vec3(blurSample) * uPatternBlur * 0.1;
          }

          // Debug: Ensure some color is always output
          if (color == vec3(0.0) && mask > 0.1) {
            color = vec3(1.0, 0.0, 0.0); // Red for debugging
          }

          gl_FragColor = vec4(color, mask);
        }
      `
    });

    // Geometry and mesh
    const geometry = new THREE.PlaneGeometry(2, 2);
    const mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      uniforms.uTime.value += 0.016;
      renderer.render(scene, camera);
    }
    animate();

    // Handle slider inputs
    const sliders = {
      refraction: document.getElementById('refraction'),
      edge: document.getElementById('edge'),
      patternBlur: document.getElementById('patternBlur'),
      liquid: document.getElementById('liquid'),
      speed: document.getElementById('speed'),
      patternScale: document.getElementById('patternScale')
    };

    Object.keys(sliders).forEach(key => {
      const slider = sliders[key];
      slider.addEventListener('input', () => {
        uniforms[`u${key.charAt(0).toUpperCase() + key.slice(1)}`].value = parseFloat(slider.value);
        slider.nextElementSibling.textContent = parseFloat(slider.value).toFixed(3);
      });
    });

    // Handle background picker
    const backgroundPicker = document.querySelectorAll('.background-picker div');
    backgroundPicker.forEach(div => {
      div.addEventListener('click', () => {
        backgroundPicker.forEach(d => d.classList.remove('selected'));
        div.classList.add('selected');
        const bg = div.dataset.bg;
        if (bg === 'metal') uniforms.uBackground.value.set(0.4, 0.4, 0.4);
        else if (bg === 'black') uniforms.uBackground.value.set(0.0, 0.0, 0.0);
        else uniforms.uBackground.value.set(0.5, 0.5, 0.5);
      });
    });

    // Handle window resize
    window.addEventListener('resize', () => {
      const size = Math.min(container.clientWidth, container.clientHeight);
      renderer.setSize(size, size);
    });
  </script>
</body>
</html>